
/*
Generated by ../../src/fsm_gen.py
from calc.txt
!!! DO NOT EDIT MANUALLY !!!
*/
#ifndef CALC_FSM_HEADER
#define CALC_FSM_HEADER

#include "calc.h"
#include "stdio.h"
#include "stdlib.h"

typedef struct CALC_FSM_STATE CALC_FSM_STATE;
typedef int (*calc_fsm_callback)(CALC_FSM_STATE *state, int evt, int arg, CALC_DATA *data);
typedef struct {int next_state; calc_fsm_callback callback;} CALC_FSM_EVT_ENTRY;
typedef struct {int start_evt; int size; const CALC_FSM_EVT_ENTRY *events;} CALC_FSM_STATE_ENTRY;
struct CALC_FSM_STATE {int current_state; const CALC_FSM_STATE_ENTRY *state_table;};

int calc_handle_event(CALC_FSM_STATE *state, int evt, int arg, CALC_DATA *data);
int calc_fsm_init();
enum CALC_EVENTS {
EVENT_BLANK,
EVENT_DIGIT,
EVENT_DIV,
EVENT_EQUAL,
EVENT_MINUS,
EVENT_MUL,
EVENT_PLUS,
CALC_EVT_SIZE
};
enum CALC_STATES {
IDLE_STATE,
NUMBER_ENTER,
OPER_ENTER,
SIGNUM_ENTER,
CALC_STATES_SIZE
};
#ifdef CALC_CALLBACKS
static int  on_digit_enter (CALC_FSM_STATE *state, int evt, int arg, CALC_DATA *data);
static int  on_equal_enter (CALC_FSM_STATE *state, int evt, int arg, CALC_DATA *data);
static int  on_oper_enter (CALC_FSM_STATE *state, int evt, int arg, CALC_DATA *data);
static int  on_signum_enter (CALC_FSM_STATE *state, int evt, int arg, CALC_DATA *data);
#endif /*CALC_CALLBACKS*/
#ifdef CALC_BODY
#ifndef CALC_INVALID_STATE
#define CALC_INVALID_STATE -1
#endif /*CALC_INVALID_STATE*/
#ifndef CALC_ERROR_ANSWER
#define CALC_ERROR_ANSWER -1
#endif /*CALC_ERROR_ANSWER*/
#ifndef CALC_OK_ANSWER
#define CALC_OK_ANSWER 0
#endif /*CALC_OK_ANSWER*/

/*IDLE_STATE events*/
static const CALC_FSM_EVT_ENTRY idle_state_events[] = {
 { IDLE_STATE, NULL } /*EVENT_BLANK*/
,{ NUMBER_ENTER, on_digit_enter } /*EVENT_DIGIT*/
,{ CALC_INVALID_STATE, NULL } /*EVENT_DIV*/
,{ CALC_INVALID_STATE, NULL } /*EVENT_EQUAL*/
,{ SIGNUM_ENTER, on_signum_enter } /*EVENT_MINUS*/
,{ CALC_INVALID_STATE, NULL } /*EVENT_MUL*/
,{ SIGNUM_ENTER, on_signum_enter } /*EVENT_PLUS*/
};


/*NUMBER_ENTER events*/
static const CALC_FSM_EVT_ENTRY number_enter_events[] = {
 { NUMBER_ENTER, NULL } /*EVENT_BLANK*/
,{ NUMBER_ENTER, on_digit_enter } /*EVENT_DIGIT*/
,{ OPER_ENTER, on_oper_enter } /*EVENT_DIV*/
,{ IDLE_STATE, on_equal_enter } /*EVENT_EQUAL*/
,{ OPER_ENTER, on_oper_enter } /*EVENT_MINUS*/
,{ OPER_ENTER, on_oper_enter } /*EVENT_MUL*/
,{ OPER_ENTER, on_oper_enter } /*EVENT_PLUS*/
};


/*OPER_ENTER events*/
static const CALC_FSM_EVT_ENTRY oper_enter_events[] = {
 { OPER_ENTER, NULL } /*EVENT_BLANK*/
,{ NUMBER_ENTER, on_digit_enter } /*EVENT_DIGIT*/
,{ CALC_INVALID_STATE, NULL } /*EVENT_DIV*/
,{ CALC_INVALID_STATE, NULL } /*EVENT_EQUAL*/
,{ SIGNUM_ENTER, on_signum_enter } /*EVENT_MINUS*/
,{ CALC_INVALID_STATE, NULL } /*EVENT_MUL*/
,{ SIGNUM_ENTER, on_signum_enter } /*EVENT_PLUS*/
};


/*SIGNUM_ENTER events*/
static const CALC_FSM_EVT_ENTRY signum_enter_events[] = {
 { SIGNUM_ENTER, NULL } /*EVENT_BLANK*/
,{ NUMBER_ENTER, on_digit_enter } /*EVENT_DIGIT*/
};


/*State table*/
static const CALC_FSM_STATE_ENTRY state_table[] = {
/*IDLE_STATE state*/
 { EVENT_BLANK,  EVENT_PLUS - EVENT_BLANK + 1, idle_state_events }
/*NUMBER_ENTER state*/
,{ EVENT_BLANK,  EVENT_PLUS - EVENT_BLANK + 1, number_enter_events }
/*OPER_ENTER state*/
,{ EVENT_BLANK,  EVENT_PLUS - EVENT_BLANK + 1, oper_enter_events }
/*SIGNUM_ENTER state*/
,{ EVENT_BLANK,  EVENT_DIGIT - EVENT_BLANK + 1, signum_enter_events }
};



int calc_fsm_init(CALC_FSM_STATE *dst)
{
  dst->current_state = IDLE_STATE;
  dst->state_table = state_table;
  return 0;
}
int calc_handle_event (CALC_FSM_STATE *state, int evt, int arg, CALC_DATA *data)
{
  const CALC_FSM_STATE_ENTRY *state_entry;
  int index;
  if(state->current_state < 0 || state->current_state >= CALC_STATES_SIZE)
  {
#ifndef CALC_IGNORE_ERROR
    state->current_state = IDLE_STATE;
    fprintf(stderr, "Invalid event '%c' %d\n", arg, evt); calculator_reset(data);
#endif /*CALC_IGNORE_ERROR*/
    return CALC_ERROR_ANSWER;
  }
  state_entry = &state->state_table[state->current_state];
  index = evt - state_entry->start_evt;
  if(index < 0
    || index >= state_entry->size
    || CALC_INVALID_STATE == state_entry->events[index].next_state)
  {
#ifndef CALC_IGNORE_ERROR
    state->current_state = IDLE_STATE;
    fprintf(stderr, "Invalid event '%c' %d\n", arg, evt); calculator_reset(data);
#endif /*CALC_IGNORE_ERROR*/
    return CALC_ERROR_ANSWER;
  }
  state->current_state = state_entry->events[index].next_state;
  if(state_entry->events[index].callback != NULL)
    return state_entry->events[index].callback(state,evt,arg,data);
  return CALC_OK_ANSWER;
}
#endif /*CALC_BODY*/


#endif /*CALC_FSM_HEADER*/
